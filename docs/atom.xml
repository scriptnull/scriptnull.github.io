<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vishnu Bharathi</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://vishnubharathi.codes/"/>
  <updated>2020-07-20T11:07:17.273Z</updated>
  <id>https://vishnubharathi.codes/</id>
  
  <author>
    <name>Vishnu Bharathi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>First feedback</title>
    <link href="https://vishnubharathi.codes/blog/first-feedback/"/>
    <id>https://vishnubharathi.codes/blog/first-feedback/</id>
    <published>2020-07-20T07:57:19.000Z</published>
    <updated>2020-07-20T11:07:17.273Z</updated>
    
    <content type="html"><![CDATA[<p>I just got off from a call where I gathered feedback about my interview with a company. I didn‚Äôt pass the interview, but the feedback of why I failed is making have an immense smile in my face for the past hour.</p><p>This is the first company that I applied after I lost my job a few days back. So, this is the <em>first feedback</em> that I got in that sense. I think writing it down here would give me a solid place to refer to on a regular basis to up my game!</p><p>The feedback call was between me and the CTO of the company. Whenever I find myself talking to CEOs, CTOs and VPs (and some Engineers), I seem to get immense amount of ‚ÄúYou are playing a different game, so game on!‚Äù level of energy from the conversation. This is nonetheless different. The way things were put infront of me is actually something helpful that I could act upon.</p><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>To give background, here is how the interview process went. It is an early-stage startup, recently funded, super-interesting to me (as it is in the Reliability, Observability space). I saw their CTO‚Äôs tweet that they are hiring.</p><p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">We (<a href="https://twitter.com/last9inc?ref_src=twsrc%5Etfw" target="_blank" rel="noopener">@last9inc</a>) are looking for a Software Engineer who can <em>own</em> our Reliability + Customer Integration pipeline. <br><br>Key requisites are: Strong *nix skills, and being able to think ahead and automate mundane / repetitive work.<br><br>If that&#39;s not you, help spread the word üôè</p>&mdash; Piyush Verma (@realmeson10) <a href="https://twitter.com/realmeson10/status/1273551418448740352?ref_src=twsrc%5Etfw" target="_blank" rel="noopener">June 18, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p><p>After doing my homework on what they are trying to do, I arrived at one of their interesting projects which is open source - <a href="https://github.com/last9/k8stream" target="_blank" rel="noopener">https://github.com/last9/k8stream</a></p><p>Now I am fully convinced that I should definitely apply to them! <code>k8stream</code> was written in Go, which I am currently focusing on. So I thought it might be good to contribute a feature to the project, that way I get a little bit better in Go programming and also it would help me break the ice with them while applying!</p><p>It is a project that uploads various kuberenetes events to AWS S3. It had this notion of Sink, which lets you store the data. For example, there was file sink and AWS sink. You can choose the sink in which your events should get stored. My initial idea was to add a GCS sink, which would enable storing events in Google Cloud storage. During the ‚Äúexploring by reading the code‚Äù phase, I happened to notice a <code>TODO</code> comment in the code base and I felt it would be more valuable to address it rather than sending code for feature that I wasn‚Äôt sure if they are interested in having in the software. So, here it is: <a href="https://github.com/last9/k8stream/pull/38" target="_blank" rel="noopener">https://github.com/last9/k8stream/pull/38</a> - a PR to validate input in file sink!</p><p>One of the other reasons for not going with GCS feature is that I didn‚Äôt have clear idea about how to use <code>context</code> package in Go (this package was used extensively by the google cloud Go library). So, I did spin off understanding it parallely during the process and ended up <a href="/blog/go-contexts/">digging deep into the source code of context package and writing a blog post about it</a></p><p>After sending in a hello email with a pointer to my PR, I was able to get an interview from them. It involved a introduction/get-to-know-each-other call followed by a take home assignment.</p><p>The call went well. Then I wrote and submitted the take-home assignment in a week. I chose Go as my programming language (as I was learning it and I thought it would be a fun exercise).</p><p>I learnt that I was rejected in some days after the assignment and after a week, I was able to get the CTO on call for a feedback session. </p><h2 id="Good-things"><a href="#Good-things" class="headerlink" title="Good things"></a>Good things</h2><p>Always start with the good things! A few things that they thought I was good at.</p><ul><li>Good hands on coding skills</li><li>Willing to accept feedback and act on it.</li><li>Passionate and enthusiastic.</li></ul><h2 id="Things-that-went-wrong"><a href="#Things-that-went-wrong" class="headerlink" title="Things that went wrong"></a>Things that went wrong</h2><p>The following were somethings that went wrong. </p><ul><li>Overly engineered solution.</li><li>Lagging in design principles.</li><li>Parts of the solution was lacking in testability.</li></ul><h2 id="To-be-Improved"><a href="#To-be-Improved" class="headerlink" title="To be Improved"></a>To be Improved</h2><p>So, from the feedback, I understood that the following things need to be improved.</p><ul><li>Sense and knowledge of design patterns. (Totally agree with this!)</li><li>Knowledge on basic functional programming constructs like Pure function, idompotence etc.</li><li>Knowledge on system design and architecture.</li></ul><h2 id="But-how"><a href="#But-how" class="headerlink" title="But, how?"></a>But, how?</h2><p>Now that I know what needs to be improved. I am laying down what can I do to start seeing the results.</p><p>I also asked questions to the CTO like ‚ÄúIf I were to apply back again, what are some action items that I can take to improve myself?‚Äù hoping that I could get some suggestions on improving.</p><p>First thing was,</p><blockquote><p>Code more, a lot more.</p></blockquote><p>Woah! that‚Äôs super straight forward. I love this. I just have to write a lot more code everyday. I had been missing it for a while. When I was in college, I could dump these mountains of code everyday that would teach me things I never knew of. So I want to get back on ‚Äúthat level of coding more‚Äù.</p><p>Next was my very favorite part in the entire of the conversation. It was about how to get good at design patterns. I find it very practical advice.</p><blockquote><p>Build something with some assumptions and maintain it till you see your assumptions fail</p></blockquote><p>This case naturally leads to refactoring of code and helps you understand why your code didn‚Äôt scale. In other words, it will get us started with thinking what kind of design pattern might have saved us from having to refactor.</p><h2 id="That‚Äôs-it"><a href="#That‚Äôs-it" class="headerlink" title="That‚Äôs it"></a>That‚Äôs it</h2><p>That‚Äôs pretty much of what happened. In the end, I also got the suggestion of what kind of companies I should be applying for (got 3 names). They encouraged me in a manner that convinced me that I should definitely go (prepare and) apply at those ‚Äú3 names‚Äù after this. The entire feedback session gave me a moral boost - ‚ÄúI got this!‚Äù attitude++.</p><p>With high hopes of working towards improving myself, I am signing this off with this wonder statement: ‚ÄúI really wonder how the tech interview process has evolved in the industry. From not getting any answer back in case of rejection to requesting and getting feedback in case of a rejection.‚Äù - I am really glad to see more companies adopt this style of interviewing.</p><p>~ ~ ~ ~ </p><p>Also if you have some suggestions on how I can level up, do let me know. It would be great if you could point me to opportunities that you find interesting these days!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;I just got off from a call where I gathered feedback about my interview with a company. I didn‚Äôt pass the interview, but the feedback of 
      
    
    </summary>
    
    
      <category term="interviewing" scheme="https://vishnubharathi.codes/tags/interviewing/"/>
    
      <category term="tech interviews" scheme="https://vishnubharathi.codes/tags/tech-interviews/"/>
    
  </entry>
  
  <entry>
    <title>Migrated my old blog posts from Medium</title>
    <link href="https://vishnubharathi.codes/blog/migrated-my-old-blog-posts-from-medium/"/>
    <id>https://vishnubharathi.codes/blog/migrated-my-old-blog-posts-from-medium/</id>
    <published>2020-07-19T14:30:04.000Z</published>
    <updated>2020-07-20T11:07:17.277Z</updated>
    
    <content type="html"><![CDATA[<p>Today I spent an hour or so in migrating my old blog posts present at medium.com to this site. Medium gave me a good playground to start blogging. I really appreciate it. But as time passed on, I understood that it is good to have control over our data and host it ourself.</p><p>Medium is free to use. I mean, what really is free to use! The price I needed to pay for hosting my content on medium was to accept the big ‚Äúsign up to medium‚Äù wall that they put on all of the blog posts. Also, they encourage content creators to add a paywall to their content, which is fine for people who are looking to monetize their content.</p><p>But at least for me, the reason I write these blog post is for fun. So I intend to keep it free by hosting it myself. This is a migration that I wanted to do for a long time, and finally I am able to partially complete it.</p><p>Why partially? because there is still some images on this blog, which are hosted on some other sites like medium CDN or Github CDN. That is still remaning.</p><p>At least, I was able give my old content it‚Äôs real shelter today! (Most of them were from 2017)</p><p>Thanks to this amazing project - <a href="https://github.com/xdamman/mediumexporter" target="_blank" rel="noopener">https://github.com/xdamman/mediumexporter</a> ; that helped me in this migration!</p><p>Also, <code>sblog</code> ( <a href="https://github.com/scriptnull/sblog" target="_blank" rel="noopener">https://github.com/scriptnull/sblog</a> ) helped in some level of automation in the process. lol, becoming useful already :D</p><p>EDIT: oops, I just missed one point - The reason I did this migation is same as the reason why I would not sign up for <a href="https://substack.com/" target="_blank" rel="noopener">https://substack.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Today I spent an hour or so in migrating my old blog posts present at medium.com to this site. Medium gave me a good playground to start 
      
    
    </summary>
    
    
      <category term="blogging" scheme="https://vishnubharathi.codes/tags/blogging/"/>
    
  </entry>
  
  <entry>
    <title>Short</title>
    <link href="https://vishnubharathi.codes/blog/short/"/>
    <id>https://vishnubharathi.codes/blog/short/</id>
    <published>2020-07-16T05:55:08.000Z</published>
    <updated>2020-07-20T11:07:17.277Z</updated>
    
    <content type="html"><![CDATA[<p>Every time I start a blog post, the words and ideas start playing around me and I just feel compelled to write down everything every time.</p><p>While long-form, detailed blog posts are great for describing ideas in depth, I have been wanting to write some short blog posts just like this one!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Every time I start a blog post, the words and ideas start playing around me and I just feel compelled to write down everything every time
      
    
    </summary>
    
    
      <category term="blogging" scheme="https://vishnubharathi.codes/tags/blogging/"/>
    
  </entry>
  
  <entry>
    <title>Releasing sblog</title>
    <link href="https://vishnubharathi.codes/blog/releasing-sblog/"/>
    <id>https://vishnubharathi.codes/blog/releasing-sblog/</id>
    <published>2020-07-15T15:20:20.000Z</published>
    <updated>2020-07-20T11:07:17.277Z</updated>
    
    <content type="html"><![CDATA[<p>Today, I wrote a very simple utility that helps me kickstart new blog posts. In fact, this is the first blog post bootstrapped with the utility.</p><p>I have named it <code>sblog</code> - short for ‚ÄúStart a new blog post‚Äù</p><p>It just saves a few seconds of my time and frees me from manually typing timestamps in my blog post headers everytime.</p><p>I have been continously trying to bring down the friction in starting and publishing blog posts for a long time. This is probably a small step in that path.</p><p>My first effort was full automation of writing blog posts via Github Editor and publishing it by commiting the markdown file. You could read all about it from here - <a href="https://vishnubharathi.codes/blog/auto/">https://vishnubharathi.codes/blog/auto/</a></p><p>After that I have been using Bookmarks for creating new post and uploading new image to my blog.</p><p><img src="/images/blog-bookmarks.png" alt="blog-bookmarks"></p><p>This used to give me a blank blog post page like </p><p><img src="/images/blank-blog-post.png" alt="blank-blog-post"></p><p>I have to manually type in the filename like <code>releasing-sblog.md</code> for creating a blog post like this and fill in the content with the following YAML front matter.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Releasing</span> <span class="string">sblog</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020</span><span class="bullet">-07</span><span class="bullet">-15</span> <span class="number">20</span><span class="string">:50:20</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">["automation","blogging"]</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>That‚Äôs some effort and I don‚Äôt feel very fluid about my workflow.</p><p>So today, I am releasing a small utility called <code>sblog</code>.</p><p>Here is how it works,</p><p>When I want to start a new blog post, I run</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sblog <span class="string">"Releasing sblog"</span> <span class="string">"automation,blogging"</span></span><br></pre></td></tr></table></figure><p> That‚Äôs it! It magically opens the browser with autogenerated content to help me get right to the content of the blog post.</p><p> <img src="/images/sblog-screenshot.png" alt="sblog-screenshot"></p><p> The source is available in the open - <a href="https://github.com/scriptnull/sblog" target="_blank" rel="noopener">https://github.com/scriptnull/sblog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Today, I wrote a very simple utility that helps me kickstart new blog posts. In fact, this is the first blog post bootstrapped with the u
      
    
    </summary>
    
    
      <category term="blogging" scheme="https://vishnubharathi.codes/tags/blogging/"/>
    
      <category term="automation" scheme="https://vishnubharathi.codes/tags/automation/"/>
    
  </entry>
  
  <entry>
    <title>Under the hood of Go&#39;s context</title>
    <link href="https://vishnubharathi.codes/blog/go-contexts/"/>
    <id>https://vishnubharathi.codes/blog/go-contexts/</id>
    <published>2020-06-29T22:32:00.000Z</published>
    <updated>2020-07-20T11:07:17.273Z</updated>
    
    <content type="html"><![CDATA[<p>This post is dedicated to you if you had used the Go programming language and ever wondered ‚ÄúWhat is a context anyway?‚Äù.</p><p><code>context</code> is a package in Go‚Äôs standard library. I think <code>context</code> is idiomatic Go, hence I find quite some external packages and standard library packages using it.</p><p>You can read all about it from here - <a href="https://golang.org/pkg/context/" target="_blank" rel="noopener">https://golang.org/pkg/context/</a></p><p>What I am trying to do here is just walk through the implementation details of the context package by reading the source file of it.</p><p>I can‚Äôt guarantee if you could fully follow my writings here. But, I just want you to leave with a mindset that ‚ÄúInternal implementations of OSS software are always accessible for anyone to read. We just have to make time for it!‚Äù.</p><p>Giving <a href="https://golang.org/src/context/context.go" target="_blank" rel="noopener">the link</a> to the source file of the <code>context</code> package, just in case if you want read the source directly and understand it in your style.</p><h2 id="What-is-it"><a href="#What-is-it" class="headerlink" title="What is it?"></a>What is it?</h2><p>Bare minimum, copy pasted from the docs.</p><blockquote><p>Package context defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes.</p></blockquote><p>It can usually be seen as the first argument to a function call.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">(ctx context.Context, arg Arg)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// ... use ctx ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="When-should-you-use-it"><a href="#When-should-you-use-it" class="headerlink" title="When should you use it?"></a>When should you use it?</h2><p>There is this interesting one-liner from the docs, </p><blockquote><p>Incoming requests to a server should create a Context, and outgoing calls to servers should accept a Context.</p></blockquote><p>So if you are buiding a server or client application in Go, then you will have to deal with contexts.</p><p>That leads to why it has the following concurrent nature.</p><blockquote><p>The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines.</p></blockquote><p>It is mainly used for propagating a request‚Äôs state across function calls.</p><p>I am going to ask a ‚ÄúSorry‚Äù and silently try to assume its usage feels like the <code>req</code> object in <a href="https://expressjs.com/en/guide/using-middleware.html" target="_blank" rel="noopener">express middlewares</a></p><p>You have to skip reading this stuff if you are not looking to read JavaScript. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> <span class="title">middleware1</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// req is mutated to pass down the state of request to next middleware</span></span><br><span class="line">  req.user = &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">role</span>: <span class="string">'admin'</span> &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> <span class="title">middleware2</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (req.user.role === <span class="string">'admin'</span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Note how we pass in data across function calls using the <code>req</code> object. I think a context has similar functionality.</p><h2 id="How-to-and-How-not-to"><a href="#How-to-and-How-not-to" class="headerlink" title="How to and How not to?"></a>How to and How not to?</h2><p>Always propagate contexts as arguments to function and don‚Äôt store it in a struct. That‚Äôs some bulletproof wisdom from docs for you! :D</p><blockquote><p>Pass context.TODO if you are unsure about which Context to use.</p></blockquote><p>The above one-line statement is probably what triggered me to do this deep dive - Why are people (myself included) becoming unaware of what context to use?</p><blockquote><p>Do not pass a nil Context, even if a function permits it. </p></blockquote><p>That is enough copy-pastes from the docs.</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><img src="/images/go-context-doc.png" alt="go-context"></p><p>That is all of context for you!</p><h2 id="The-interface"><a href="#The-interface" class="headerlink" title="The interface"></a>The interface</h2><p>At its core lies the <code>Context</code> interface. it is the object that gets sent around. woah! I always imagined it to be struct. Now it is interesting to note that it is an interface.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (dealine time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() error</span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This seems to accomodate the information used by various API methods of the context package.</p><h2 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h2><p>context package defines errors which are returned by the <code>Err()</code> method if the channel returned by <code>Done()</code> is closed. This error message is used to communicate what made the channel close.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Canceled = errors.New(<span class="string">"context canceled"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> deadlineExceededError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span>   &#123; <span class="keyword">return</span> <span class="string">"context deadline exceeded"</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span> <span class="title">Timeout</span><span class="params">()</span> <span class="title">bool</span></span>   &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span> <span class="title">Temporary</span><span class="params">()</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="Empty-context"><a href="#Empty-context" class="headerlink" title="Empty context"></a>Empty context</h2><p>Next up is an empty context. It is a context with no value, no deadline and is never cancelled. Lets see how it is defined and where it is used.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *emptyCtx)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> e &#123;</span><br><span class="line"><span class="keyword">case</span> background:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"context.Background"</span></span><br><span class="line"><span class="keyword">case</span> todo:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"context.TODO"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"unknown empty Context"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Now that we have an empty context. It seems like both <code>context.Background()</code> and <code>context.TODO()</code> return an empty context. So when you are creating a context this is probably where we start.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Cancel-Context"><a href="#Cancel-Context" class="headerlink" title="Cancel Context"></a>Cancel Context</h2><p>Things start to complicate from this point onwards. Now that we have some empty contexts that could be used as the starting point / parent for other kind of complex contexts such as context with cancel/deadline/timeout.</p><p>Here we will try to explore the inner workings of <code>context.WithCancel</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span></span><br></pre></td></tr></table></figure><p>By the looks of its method signature, it is obvious that ‚Äúit takes in a parent context and gives back a cancellable context‚Äù.</p><p>In that method definition, we know that the <code>Context</code> is an interface type and we notice that there is a new type called CancelFunc. Let‚Äôs see the definition of it.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A CancelFunc tells an operation to abandon its work.</span></span><br><span class="line"><span class="comment">// A CancelFunc does not wait for the work to stop.</span></span><br><span class="line"><span class="comment">// A CancelFunc may be called by multiple goroutines simultaneously.</span></span><br><span class="line"><span class="comment">// After the first call, subsequent calls to a CancelFunc do nothing.</span></span><br><span class="line"><span class="keyword">type</span> CancelFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>It is a simple function that takes 0 argument and returns 0 values.</p><p>Now let‚Äôs dig in the definition of the <code>WithCancel</code> method.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WithCancel returns a copy of parent with a new Done channel. The returned</span></span><br><span class="line"><span class="comment">// context's Done channel is closed when the returned cancel function is called</span></span><br><span class="line"><span class="comment">// or when the parent context's Done channel is closed, whichever happens first.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Canceling this context releases resources associated with it, so code should</span></span><br><span class="line"><span class="comment">// call cancel as soon as the operations running in this Context complete.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">c := newCancelCtx(parent)</span><br><span class="line">propagateCancel(parent, &amp;c)</span><br><span class="line"><span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The important thing to note here is the comment above the method.</p><p>Note that the returned context‚Äôs <code>Done</code> channel is closed either by calling the returned <code>CancelFunc</code> or if the parent context‚Äôs <code>Done</code> channel is closed.</p><h3 id="cancelCtx"><a href="#cancelCtx" class="headerlink" title="cancelCtx"></a>cancelCtx</h3><p>So as you see, the first step in the <code>WithCancel</code> method is creating a cancel context <code>c := newCancelCtx(parent)</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span> <span class="title">cancelCtx</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It just wraps the context in a struct called <code>cancelCtx</code> and returns back it. So now on to the definition of <code>cancelCtx</code> struct.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A cancelCtx can be canceled. When canceled, it also cancels any children</span></span><br><span class="line"><span class="comment">// that implement canceler.</span></span><br><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">Context</span><br><span class="line"></span><br><span class="line">mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">done     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;         <span class="comment">// created lazily, closed by first cancel call</span></span><br><span class="line">children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">err      error                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Interesting point here is the presence of mutex that guards the other values of the struct. This mechanism is the one that makes the context package implementation to be concurrent.</p><p>We note that there is a type called <code>canceler</code> used inside the struct, so checking the definition of it. </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A canceler is a context type that can be canceled directly. The</span></span><br><span class="line"><span class="comment">// implementations are *cancelCtx and *timerCtx.</span></span><br><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">cancel(removeFromParent <span class="keyword">bool</span>, err error)</span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Before we move on the the other parts of <code>WithCancel</code> function call, we will try to look at the implementation of <code>cancelCtx</code> struct. It seems to implement these  interfaces: <code>Context</code>, <code>canceller</code> and <code>stringer</code></p><h4 id="Err"><a href="#Err" class="headerlink" title="Err()"></a>Err()</h4><p>It seems to be just a wrapper for the <code>err</code> field in the <code>cancelCtx</code> struct in a thread-safe way.<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line">err := c.err</span><br><span class="line">c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Done"><a href="#Done" class="headerlink" title="Done()"></a>Done()</h4><p>Again a thread-safe wrapper for accessing the <code>done</code> field. but at the same time, it seems to create a new channel for the context if it is not already present.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">c.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">d := c.done</span><br><span class="line">c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Value"><a href="#Value" class="headerlink" title="Value()"></a>Value()</h4><p>This seem to just return the value of parent context.<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="propagateCancel"><a href="#propagateCancel" class="headerlink" title="propagateCancel"></a>propagateCancel</h3><p>So we have a new <code>cancelCtx</code> on hand right now and it is being passed down to <code>propagateCancel</code>. This just propagates cancel from the parent context to our context. If the parent‚Äôs Done channel is closed, then I think this function takes care of propagating that to the current context and make Done channel of current context closed.</p><p>First we check if the parent‚Äôs <code>Done</code> returns nil. If the parent context is also a cancelCtx and have <code>Done</code> called, this wouldn‚Äôt be nil. This might be a little confusion, but see the implementation of cancelCtx‚Äôs <code>Done</code> function to understand what it means to do the following nil comparison.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">done := parent.Done()</span><br><span class="line"><span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>After that we check if the parent channel is closed. If it is closed, then we cancel the child using the <code>cancel</code> method. We will see the implementation of <code>cancel</code> method in a short while.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="comment">// parent is already canceled</span></span><br><span class="line">child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If the channel is not closed, then we fallthrough the logic of the function. After that our flow takes two paths.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line"> ....</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>parentCancelCtx</code> is the function that returns an underlying <code>cancelCtx</code> from the given parent context.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span> <span class="params">(*cancelCtx, <span class="keyword">bool</span>)</span></span> &#123;</span><br></pre></td></tr></table></figure><p>After getting the <code>cancelCtx</code>, we seem to error out if p.err is non-nil. If the err is nil, then it means that there is a valid parent cancelCtx for which the current cancelCtx should be added as a child. We basically use a set to track the children.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">p.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// parent has already been canceled</span></span><br><span class="line">child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">p.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If it doesnot seem to have a valid underlying <code>cancelCtx</code>, we just spin up a goroutine that listens for either of the parent of child to be close its <code>Done</code> channel. We also seem to track the count of this in a variable.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">atomic.AddInt32(&amp;goroutines, +<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line"><span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h3 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h3><p>Next up, we closely examine the cancel function of the <code>cancelCtx</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cancel closes c.done, cancels each of c's children, and, if</span></span><br><span class="line"><span class="comment">// removeFromParent is true, removes c from its parent's children.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"context: internal error: missing cancel error"</span>)</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// already canceled</span></span><br><span class="line">&#125;</span><br><span class="line">c.err = err</span><br><span class="line"><span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">c.done = closedchan</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">close</span>(c.done)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> acquiring the child's lock while holding parent's lock.</span></span><br><span class="line">child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">c.children = <span class="literal">nil</span></span><br><span class="line">c.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">removeChild(c.Context, c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The code here is pretty self-explanatory. One supplement here is to add the implementation of <code>removeChild</code> method which is also a very simple, ‚Äúdelete from set‚Äù operation.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// removeChild removes a context from its parent.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeChild</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">p, ok := parentCancelCtx(parent)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">p.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> p.children != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(p.children, child)</span><br><span class="line">&#125;</span><br><span class="line">p.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WithDeadline"><a href="#WithDeadline" class="headerlink" title="WithDeadline"></a>WithDeadline</h2><p>Next up is <code>context.WithDeadline</code> which gets cancelled by calling the returned <code>cancel</code> method or if the context crosses a time deadline. It is comfortably built on top of the <code>cancelCtx</code></p><p>We will start with the method definition. It accepts a parent context and returns back a context and <code>CancelFunc</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span> <span class="params">(Context, CancelFunc)</span></span></span><br></pre></td></tr></table></figure><p>Here is step 1. </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line"><span class="comment">// The current deadline is already sooner than the new one.</span></span><br><span class="line"><span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In order to decipher this stuff, we will look up the doc of <code>Deadline</code> method in <code>Context</code> interface.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Deadline returns the time when work done on behalf of this context</span></span><br><span class="line"><span class="comment">// should be canceled. Deadline returns ok==false when no deadline is</span></span><br><span class="line"><span class="comment">// set. Successive calls to Deadline return the same results.</span></span><br><span class="line">Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>so the code in step 1 translates to ‚ÄúIf the parent context has a deadline set &amp;&amp; if the parent‚Äôs deadline is before the current deadline‚Äù, we return back the parent using <code>WithCancel(parent)</code>. Because in this case, the parent would expire first, thus resulting in cancelling the child context automatically.</p><p>After that, we know that the deadline of the current context occurs before the parent context. So this is what we do.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c := &amp;timerCtx&#123;</span><br><span class="line">cancelCtx: newCancelCtx(parent),</span><br><span class="line">deadline:  d,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let is explore the definition of <code>timerCtx</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A timerCtx carries a timer and a deadline. It embeds a cancelCtx to</span></span><br><span class="line"><span class="comment">// implement Done and Err. It implements cancel by stopping its timer then</span></span><br><span class="line"><span class="comment">// delegating to cancelCtx.cancel.</span></span><br><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">cancelCtx</span><br><span class="line">timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As the comment says, its Err and Done implementation come from <code>cancelCtx</code>. Apart from that let us explore the methods associated with it.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.deadline, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> contextName(c.cancelCtx.Context) + <span class="string">".WithDeadline("</span> +</span><br><span class="line">c.deadline.String() + <span class="string">" ["</span> +</span><br><span class="line">time.Until(c.deadline).String() + <span class="string">"])"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">c.cancelCtx.cancel(<span class="literal">false</span>, err)</span><br><span class="line"><span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line"><span class="comment">// Remove this timerCtx from its parent cancelCtx's children.</span></span><br><span class="line">removeChild(c.cancelCtx.Context, c)</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">c.timer.Stop()</span><br><span class="line">c.timer = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now that we know the details of <code>timerCtx</code>, we can go back to exploring the <code>WithDeadline</code> method. After having a timerCtx, we propagate the cancel from parent to children.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">propagateCancel(parent, c)</span><br></pre></td></tr></table></figure><p>This method is the same used before in <code>cancelCtx</code>. This adds the behaviour of ‚ÄúIf the parent‚Äôs Done channel is closed, then the children‚Äôs done channel will also be closed.‚Äù</p><p>Next we calculate the duration of the deadline for the given context.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dur := time.Until(d)</span><br><span class="line"><span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// deadline has already passed</span></span><br><span class="line"><span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If the deadline is gone, then we immediately cancel the context and send back the context. Now if there is a valid duration, we will <code>cancel</code> the current context after the given duration.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>At the last we return back the context and <code>cancelFunc</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br></pre></td></tr></table></figure><h2 id="WithTimeout"><a href="#WithTimeout" class="headerlink" title="WithTimeout"></a>WithTimeout</h2><p>Now this becomes easy-peasy. Write a wrapper on top of <code>WithDuration</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Canceling this context releases resources associated with it, so code should</span></span><br><span class="line"><span class="comment">// call cancel as soon as the operations running in this Context complete:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// func slowOperationWithTimeout(ctx context.Context) (Result, error) &#123;</span></span><br><span class="line"><span class="comment">// ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)</span></span><br><span class="line"><span class="comment">// defer cancel()  // releases resources if slowOperation completes before timeout elapses</span></span><br><span class="line"><span class="comment">// return slowOperation(ctx)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue"></a>WithValue</h2><p>We are coming close to doing this fully! We can read <code>WithValue</code> implementation in one go. It is a mix of <code>Context</code> and <code>key</code>-<code>value</code> pair.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WithValue returns a copy of parent in which the value associated with key is</span></span><br><span class="line"><span class="comment">// val.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Use context Values only for request-scoped data that transits processes and</span></span><br><span class="line"><span class="comment">// APIs, not for passing optional parameters to functions.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The provided key must be comparable and should not be of type</span></span><br><span class="line"><span class="comment">// string or any other built-in type to avoid collisions between</span></span><br><span class="line"><span class="comment">// packages using context. Users of WithValue should define their own</span></span><br><span class="line"><span class="comment">// types for keys. To avoid allocating when assigning to an</span></span><br><span class="line"><span class="comment">// interface&#123;&#125;, context keys often have concrete type</span></span><br><span class="line"><span class="comment">// struct&#123;&#125;. Alternatively, exported context key variables' static</span></span><br><span class="line"><span class="comment">// type should be a pointer or interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"nil key"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"key is not comparable"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A valueCtx carries a key-value pair. It implements Value for that key and</span></span><br><span class="line"><span class="comment">// delegates all other calls to the embedded Context.</span></span><br><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">Context</span><br><span class="line">key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stringify tries a bit to stringify v, without using fmt, since we don't</span></span><br><span class="line"><span class="comment">// want context depending on the unicode tables. This is only used by</span></span><br><span class="line"><span class="comment">// *valueCtx.String().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringify</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> s := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> stringer:</span><br><span class="line"><span class="keyword">return</span> s.String()</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"&lt;not Stringer&gt;"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> contextName(c.Context) + <span class="string">".WithValue(type "</span> +</span><br><span class="line">reflectlite.TypeOf(c.key).String() +</span><br><span class="line"><span class="string">", val "</span> + stringify(c.val) + <span class="string">")"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">if</span> c.key == key &#123;</span><br><span class="line"><span class="keyword">return</span> c.val</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Done-1"><a href="#Done-1" class="headerlink" title="Done"></a>Done</h2><p>uff, finally we are done with this blog post. It stretched longer than I expected. Most of the times I used to be afraid of the <code>context</code> pacakge in Go whenever I see it in some library. Now, this excercise has given me better context about the context package and probably make me less scared about using it.</p><p>I was surprised that I was naturally able to predict that there should be something like ‚Äúcontext leak‚Äù while reading through this exercise. Hmm, so that‚Äôs for now. I would like to write about practical use case of the context API in real world codebases if I get the chance to!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This post is dedicated to you if you had used the Go programming language and ever wondered ‚ÄúWhat is a context anyway?‚Äù.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;con
      
    
    </summary>
    
    
      <category term="programming" scheme="https://vishnubharathi.codes/tags/programming/"/>
    
      <category term="go" scheme="https://vishnubharathi.codes/tags/go/"/>
    
  </entry>
  
</feed>
