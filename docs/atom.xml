<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vishnu Bharathi</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://vishnubharathi.codes/"/>
  <updated>2020-07-19T14:53:35.118Z</updated>
  <id>https://vishnubharathi.codes/</id>
  
  <author>
    <name>Vishnu Bharathi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Migrated my old blog posts from Medium</title>
    <link href="https://vishnubharathi.codes/blog/migrated-my-old-blog-posts-from-medium/"/>
    <id>https://vishnubharathi.codes/blog/migrated-my-old-blog-posts-from-medium/</id>
    <published>2020-07-19T14:30:04.000Z</published>
    <updated>2020-07-19T14:53:35.118Z</updated>
    
    <content type="html"><![CDATA[<p>Today I spent an hour or so in migrating my old blog posts present at medium.com to this site. Medium gave me a good playground to start blogging. I really appreciate it. But as time passed on, I understood that it is good to have control over our data and host it ourself.</p><p>Medium is free to use. I mean, what really is free to use! The price I needed to pay for hosting my content on medium was to accept the big “sign up to medium” wall that they put on all of the blog posts. Also, they encourage content creators to add a paywall to their content, which is fine for people who are looking to monetize their content.</p><p>But at least for me, the reason I write these blog post is for fun. So I intend to keep it free by hosting it myself. This is a migration that I wanted to do for a long time, and finally I am able to partially complete it.</p><p>Why partially? because there is still some images on this blog, which are hosted on some other sites like medium CDN or Github CDN. That is still remaning.</p><p>At least, I was able give my old content it’s real shelter today! (Most of them were from 2017)</p><p>Thanks to this amazing project - <a href="https://github.com/xdamman/mediumexporter" target="_blank" rel="noopener">https://github.com/xdamman/mediumexporter</a> ; that helped me in this migration!</p><p>Also, <code>sblog</code> ( <a href="https://github.com/scriptnull/sblog" target="_blank" rel="noopener">https://github.com/scriptnull/sblog</a> ) helped in some level of automation in the process. lol, becoming useful already :D</p><p>EDIT: oops, I just missed one point - The reason I did this migation is same as the reason why I would not sign up for <a href="https://substack.com/" target="_blank" rel="noopener">https://substack.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Today I spent an hour or so in migrating my old blog posts present at medium.com to this site. Medium gave me a good playground to start 
      
    
    </summary>
    
    
      <category term="blogging" scheme="https://vishnubharathi.codes/tags/blogging/"/>
    
  </entry>
  
  <entry>
    <title>Short</title>
    <link href="https://vishnubharathi.codes/blog/short/"/>
    <id>https://vishnubharathi.codes/blog/short/</id>
    <published>2020-07-16T05:55:08.000Z</published>
    <updated>2020-07-19T14:53:35.118Z</updated>
    
    <content type="html"><![CDATA[<p>Every time I start a blog post, the words and ideas start playing around me and I just feel compelled to write down everything every time.</p><p>While long-form, detailed blog posts are great for describing ideas in depth, I have been wanting to write some short blog posts just like this one!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Every time I start a blog post, the words and ideas start playing around me and I just feel compelled to write down everything every time
      
    
    </summary>
    
    
      <category term="blogging" scheme="https://vishnubharathi.codes/tags/blogging/"/>
    
  </entry>
  
  <entry>
    <title>Releasing sblog</title>
    <link href="https://vishnubharathi.codes/blog/releasing-sblog/"/>
    <id>https://vishnubharathi.codes/blog/releasing-sblog/</id>
    <published>2020-07-15T15:20:20.000Z</published>
    <updated>2020-07-19T14:53:35.118Z</updated>
    
    <content type="html"><![CDATA[<p>Today, I wrote a very simple utility that helps me kickstart new blog posts. In fact, this is the first blog post bootstrapped with the utility.</p><p>I have named it <code>sblog</code> - short for “Start a new blog post”</p><p>It just saves a few seconds of my time and frees me from manually typing timestamps in my blog post headers everytime.</p><p>I have been continously trying to bring down the friction in starting and publishing blog posts for a long time. This is probably a small step in that path.</p><p>My first effort was full automation of writing blog posts via Github Editor and publishing it by commiting the markdown file. You could read all about it from here - <a href="https://vishnubharathi.codes/blog/auto/">https://vishnubharathi.codes/blog/auto/</a></p><p>After that I have been using Bookmarks for creating new post and uploading new image to my blog.</p><p><img src="/images/blog-bookmarks.png" alt="blog-bookmarks"></p><p>This used to give me a blank blog post page like </p><p><img src="/images/blank-blog-post.png" alt="blank-blog-post"></p><p>I have to manually type in the filename like <code>releasing-sblog.md</code> for creating a blog post like this and fill in the content with the following YAML front matter.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Releasing</span> <span class="string">sblog</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020</span><span class="bullet">-07</span><span class="bullet">-15</span> <span class="number">20</span><span class="string">:50:20</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">["automation","blogging"]</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>That’s some effort and I don’t feel very fluid about my workflow.</p><p>So today, I am releasing a small utility called <code>sblog</code>.</p><p>Here is how it works,</p><p>When I want to start a new blog post, I run</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sblog <span class="string">"Releasing sblog"</span> <span class="string">"automation,blogging"</span></span><br></pre></td></tr></table></figure><p> That’s it! It magically opens the browser with autogenerated content to help me get right to the content of the blog post.</p><p> <img src="/images/sblog-screenshot.png" alt="sblog-screenshot"></p><p> The source is available in the open - <a href="https://github.com/scriptnull/sblog" target="_blank" rel="noopener">https://github.com/scriptnull/sblog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Today, I wrote a very simple utility that helps me kickstart new blog posts. In fact, this is the first blog post bootstrapped with the u
      
    
    </summary>
    
    
      <category term="blogging" scheme="https://vishnubharathi.codes/tags/blogging/"/>
    
      <category term="automation" scheme="https://vishnubharathi.codes/tags/automation/"/>
    
  </entry>
  
  <entry>
    <title>Under the hood of Go&#39;s context</title>
    <link href="https://vishnubharathi.codes/blog/go-contexts/"/>
    <id>https://vishnubharathi.codes/blog/go-contexts/</id>
    <published>2020-06-29T22:32:00.000Z</published>
    <updated>2020-07-19T14:53:35.114Z</updated>
    
    <content type="html"><![CDATA[<p>This post is dedicated to you if you had used the Go programming language and ever wondered “What is a context anyway?”.</p><p><code>context</code> is a package in Go’s standard library. I think <code>context</code> is idiomatic Go, hence I find quite some external packages and standard library packages using it.</p><p>You can read all about it from here - <a href="https://golang.org/pkg/context/" target="_blank" rel="noopener">https://golang.org/pkg/context/</a></p><p>What I am trying to do here is just walk through the implementation details of the context package by reading the source file of it.</p><p>I can’t guarantee if you could fully follow my writings here. But, I just want you to leave with a mindset that “Internal implementations of OSS software are always accessible for anyone to read. We just have to make time for it!”.</p><p>Giving <a href="https://golang.org/src/context/context.go" target="_blank" rel="noopener">the link</a> to the source file of the <code>context</code> package, just in case if you want read the source directly and understand it in your style.</p><h2 id="What-is-it"><a href="#What-is-it" class="headerlink" title="What is it?"></a>What is it?</h2><p>Bare minimum, copy pasted from the docs.</p><blockquote><p>Package context defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes.</p></blockquote><p>It can usually be seen as the first argument to a function call.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">(ctx context.Context, arg Arg)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// ... use ctx ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="When-should-you-use-it"><a href="#When-should-you-use-it" class="headerlink" title="When should you use it?"></a>When should you use it?</h2><p>There is this interesting one-liner from the docs, </p><blockquote><p>Incoming requests to a server should create a Context, and outgoing calls to servers should accept a Context.</p></blockquote><p>So if you are buiding a server or client application in Go, then you will have to deal with contexts.</p><p>That leads to why it has the following concurrent nature.</p><blockquote><p>The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines.</p></blockquote><p>It is mainly used for propagating a request’s state across function calls.</p><p>I am going to ask a “Sorry” and silently try to assume its usage feels like the <code>req</code> object in <a href="https://expressjs.com/en/guide/using-middleware.html" target="_blank" rel="noopener">express middlewares</a></p><p>You have to skip reading this stuff if you are not looking to read JavaScript. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> <span class="title">middleware1</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// req is mutated to pass down the state of request to next middleware</span></span><br><span class="line">  req.user = &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">role</span>: <span class="string">'admin'</span> &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> <span class="title">middleware2</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (req.user.role === <span class="string">'admin'</span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Note how we pass in data across function calls using the <code>req</code> object. I think a context has similar functionality.</p><h2 id="How-to-and-How-not-to"><a href="#How-to-and-How-not-to" class="headerlink" title="How to and How not to?"></a>How to and How not to?</h2><p>Always propagate contexts as arguments to function and don’t store it in a struct. That’s some bulletproof wisdom from docs for you! :D</p><blockquote><p>Pass context.TODO if you are unsure about which Context to use.</p></blockquote><p>The above one-line statement is probably what triggered me to do this deep dive - Why are people (myself included) becoming unaware of what context to use?</p><blockquote><p>Do not pass a nil Context, even if a function permits it. </p></blockquote><p>That is enough copy-pastes from the docs.</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><img src="/images/go-context-doc.png" alt="go-context"></p><p>That is all of context for you!</p><h2 id="The-interface"><a href="#The-interface" class="headerlink" title="The interface"></a>The interface</h2><p>At its core lies the <code>Context</code> interface. it is the object that gets sent around. woah! I always imagined it to be struct. Now it is interesting to note that it is an interface.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (dealine time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() error</span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This seems to accomodate the information used by various API methods of the context package.</p><h2 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h2><p>context package defines errors which are returned by the <code>Err()</code> method if the channel returned by <code>Done()</code> is closed. This error message is used to communicate what made the channel close.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Canceled = errors.New(<span class="string">"context canceled"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> deadlineExceededError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span>   &#123; <span class="keyword">return</span> <span class="string">"context deadline exceeded"</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span> <span class="title">Timeout</span><span class="params">()</span> <span class="title">bool</span></span>   &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span> <span class="title">Temporary</span><span class="params">()</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="Empty-context"><a href="#Empty-context" class="headerlink" title="Empty context"></a>Empty context</h2><p>Next up is an empty context. It is a context with no value, no deadline and is never cancelled. Lets see how it is defined and where it is used.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *emptyCtx)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> e &#123;</span><br><span class="line"><span class="keyword">case</span> background:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"context.Background"</span></span><br><span class="line"><span class="keyword">case</span> todo:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"context.TODO"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"unknown empty Context"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Now that we have an empty context. It seems like both <code>context.Background()</code> and <code>context.TODO()</code> return an empty context. So when you are creating a context this is probably where we start.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Cancel-Context"><a href="#Cancel-Context" class="headerlink" title="Cancel Context"></a>Cancel Context</h2><p>Things start to complicate from this point onwards. Now that we have some empty contexts that could be used as the starting point / parent for other kind of complex contexts such as context with cancel/deadline/timeout.</p><p>Here we will try to explore the inner workings of <code>context.WithCancel</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span></span><br></pre></td></tr></table></figure><p>By the looks of its method signature, it is obvious that “it takes in a parent context and gives back a cancellable context”.</p><p>In that method definition, we know that the <code>Context</code> is an interface type and we notice that there is a new type called CancelFunc. Let’s see the definition of it.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A CancelFunc tells an operation to abandon its work.</span></span><br><span class="line"><span class="comment">// A CancelFunc does not wait for the work to stop.</span></span><br><span class="line"><span class="comment">// A CancelFunc may be called by multiple goroutines simultaneously.</span></span><br><span class="line"><span class="comment">// After the first call, subsequent calls to a CancelFunc do nothing.</span></span><br><span class="line"><span class="keyword">type</span> CancelFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>It is a simple function that takes 0 argument and returns 0 values.</p><p>Now let’s dig in the definition of the <code>WithCancel</code> method.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WithCancel returns a copy of parent with a new Done channel. The returned</span></span><br><span class="line"><span class="comment">// context's Done channel is closed when the returned cancel function is called</span></span><br><span class="line"><span class="comment">// or when the parent context's Done channel is closed, whichever happens first.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Canceling this context releases resources associated with it, so code should</span></span><br><span class="line"><span class="comment">// call cancel as soon as the operations running in this Context complete.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">c := newCancelCtx(parent)</span><br><span class="line">propagateCancel(parent, &amp;c)</span><br><span class="line"><span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The important thing to note here is the comment above the method.</p><p>Note that the returned context’s <code>Done</code> channel is closed either by calling the returned <code>CancelFunc</code> or if the parent context’s <code>Done</code> channel is closed.</p><h3 id="cancelCtx"><a href="#cancelCtx" class="headerlink" title="cancelCtx"></a>cancelCtx</h3><p>So as you see, the first step in the <code>WithCancel</code> method is creating a cancel context <code>c := newCancelCtx(parent)</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span> <span class="title">cancelCtx</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It just wraps the context in a struct called <code>cancelCtx</code> and returns back it. So now on to the definition of <code>cancelCtx</code> struct.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A cancelCtx can be canceled. When canceled, it also cancels any children</span></span><br><span class="line"><span class="comment">// that implement canceler.</span></span><br><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">Context</span><br><span class="line"></span><br><span class="line">mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">done     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;         <span class="comment">// created lazily, closed by first cancel call</span></span><br><span class="line">children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">err      error                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Interesting point here is the presence of mutex that guards the other values of the struct. This mechanism is the one that makes the context package implementation to be concurrent.</p><p>We note that there is a type called <code>canceler</code> used inside the struct, so checking the definition of it. </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A canceler is a context type that can be canceled directly. The</span></span><br><span class="line"><span class="comment">// implementations are *cancelCtx and *timerCtx.</span></span><br><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">cancel(removeFromParent <span class="keyword">bool</span>, err error)</span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Before we move on the the other parts of <code>WithCancel</code> function call, we will try to look at the implementation of <code>cancelCtx</code> struct. It seems to implement these  interfaces: <code>Context</code>, <code>canceller</code> and <code>stringer</code></p><h4 id="Err"><a href="#Err" class="headerlink" title="Err()"></a>Err()</h4><p>It seems to be just a wrapper for the <code>err</code> field in the <code>cancelCtx</code> struct in a thread-safe way.<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line">err := c.err</span><br><span class="line">c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Done"><a href="#Done" class="headerlink" title="Done()"></a>Done()</h4><p>Again a thread-safe wrapper for accessing the <code>done</code> field. but at the same time, it seems to create a new channel for the context if it is not already present.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">c.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">d := c.done</span><br><span class="line">c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Value"><a href="#Value" class="headerlink" title="Value()"></a>Value()</h4><p>This seem to just return the value of parent context.<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="propagateCancel"><a href="#propagateCancel" class="headerlink" title="propagateCancel"></a>propagateCancel</h3><p>So we have a new <code>cancelCtx</code> on hand right now and it is being passed down to <code>propagateCancel</code>. This just propagates cancel from the parent context to our context. If the parent’s Done channel is closed, then I think this function takes care of propagating that to the current context and make Done channel of current context closed.</p><p>First we check if the parent’s <code>Done</code> returns nil. If the parent context is also a cancelCtx and have <code>Done</code> called, this wouldn’t be nil. This might be a little confusion, but see the implementation of cancelCtx’s <code>Done</code> function to understand what it means to do the following nil comparison.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">done := parent.Done()</span><br><span class="line"><span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>After that we check if the parent channel is closed. If it is closed, then we cancel the child using the <code>cancel</code> method. We will see the implementation of <code>cancel</code> method in a short while.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="comment">// parent is already canceled</span></span><br><span class="line">child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If the channel is not closed, then we fallthrough the logic of the function. After that our flow takes two paths.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line"> ....</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>parentCancelCtx</code> is the function that returns an underlying <code>cancelCtx</code> from the given parent context.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span> <span class="params">(*cancelCtx, <span class="keyword">bool</span>)</span></span> &#123;</span><br></pre></td></tr></table></figure><p>After getting the <code>cancelCtx</code>, we seem to error out if p.err is non-nil. If the err is nil, then it means that there is a valid parent cancelCtx for which the current cancelCtx should be added as a child. We basically use a set to track the children.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">p.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// parent has already been canceled</span></span><br><span class="line">child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">p.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If it doesnot seem to have a valid underlying <code>cancelCtx</code>, we just spin up a goroutine that listens for either of the parent of child to be close its <code>Done</code> channel. We also seem to track the count of this in a variable.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">atomic.AddInt32(&amp;goroutines, +<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line"><span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h3 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h3><p>Next up, we closely examine the cancel function of the <code>cancelCtx</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cancel closes c.done, cancels each of c's children, and, if</span></span><br><span class="line"><span class="comment">// removeFromParent is true, removes c from its parent's children.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"context: internal error: missing cancel error"</span>)</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// already canceled</span></span><br><span class="line">&#125;</span><br><span class="line">c.err = err</span><br><span class="line"><span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">c.done = closedchan</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">close</span>(c.done)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> acquiring the child's lock while holding parent's lock.</span></span><br><span class="line">child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">c.children = <span class="literal">nil</span></span><br><span class="line">c.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">removeChild(c.Context, c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The code here is pretty self-explanatory. One supplement here is to add the implementation of <code>removeChild</code> method which is also a very simple, “delete from set” operation.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// removeChild removes a context from its parent.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeChild</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">p, ok := parentCancelCtx(parent)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">p.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> p.children != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(p.children, child)</span><br><span class="line">&#125;</span><br><span class="line">p.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WithDeadline"><a href="#WithDeadline" class="headerlink" title="WithDeadline"></a>WithDeadline</h2><p>Next up is <code>context.WithDeadline</code> which gets cancelled by calling the returned <code>cancel</code> method or if the context crosses a time deadline. It is comfortably built on top of the <code>cancelCtx</code></p><p>We will start with the method definition. It accepts a parent context and returns back a context and <code>CancelFunc</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span> <span class="params">(Context, CancelFunc)</span></span></span><br></pre></td></tr></table></figure><p>Here is step 1. </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line"><span class="comment">// The current deadline is already sooner than the new one.</span></span><br><span class="line"><span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In order to decipher this stuff, we will look up the doc of <code>Deadline</code> method in <code>Context</code> interface.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Deadline returns the time when work done on behalf of this context</span></span><br><span class="line"><span class="comment">// should be canceled. Deadline returns ok==false when no deadline is</span></span><br><span class="line"><span class="comment">// set. Successive calls to Deadline return the same results.</span></span><br><span class="line">Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>so the code in step 1 translates to “If the parent context has a deadline set &amp;&amp; if the parent’s deadline is before the current deadline”, we return back the parent using <code>WithCancel(parent)</code>. Because in this case, the parent would expire first, thus resulting in cancelling the child context automatically.</p><p>After that, we know that the deadline of the current context occurs before the parent context. So this is what we do.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c := &amp;timerCtx&#123;</span><br><span class="line">cancelCtx: newCancelCtx(parent),</span><br><span class="line">deadline:  d,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let is explore the definition of <code>timerCtx</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A timerCtx carries a timer and a deadline. It embeds a cancelCtx to</span></span><br><span class="line"><span class="comment">// implement Done and Err. It implements cancel by stopping its timer then</span></span><br><span class="line"><span class="comment">// delegating to cancelCtx.cancel.</span></span><br><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">cancelCtx</span><br><span class="line">timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As the comment says, its Err and Done implementation come from <code>cancelCtx</code>. Apart from that let us explore the methods associated with it.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.deadline, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> contextName(c.cancelCtx.Context) + <span class="string">".WithDeadline("</span> +</span><br><span class="line">c.deadline.String() + <span class="string">" ["</span> +</span><br><span class="line">time.Until(c.deadline).String() + <span class="string">"])"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">c.cancelCtx.cancel(<span class="literal">false</span>, err)</span><br><span class="line"><span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line"><span class="comment">// Remove this timerCtx from its parent cancelCtx's children.</span></span><br><span class="line">removeChild(c.cancelCtx.Context, c)</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">c.timer.Stop()</span><br><span class="line">c.timer = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now that we know the details of <code>timerCtx</code>, we can go back to exploring the <code>WithDeadline</code> method. After having a timerCtx, we propagate the cancel from parent to children.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">propagateCancel(parent, c)</span><br></pre></td></tr></table></figure><p>This method is the same used before in <code>cancelCtx</code>. This adds the behaviour of “If the parent’s Done channel is closed, then the children’s done channel will also be closed.”</p><p>Next we calculate the duration of the deadline for the given context.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dur := time.Until(d)</span><br><span class="line"><span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// deadline has already passed</span></span><br><span class="line"><span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If the deadline is gone, then we immediately cancel the context and send back the context. Now if there is a valid duration, we will <code>cancel</code> the current context after the given duration.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>At the last we return back the context and <code>cancelFunc</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br></pre></td></tr></table></figure><h2 id="WithTimeout"><a href="#WithTimeout" class="headerlink" title="WithTimeout"></a>WithTimeout</h2><p>Now this becomes easy-peasy. Write a wrapper on top of <code>WithDuration</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Canceling this context releases resources associated with it, so code should</span></span><br><span class="line"><span class="comment">// call cancel as soon as the operations running in this Context complete:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// func slowOperationWithTimeout(ctx context.Context) (Result, error) &#123;</span></span><br><span class="line"><span class="comment">// ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)</span></span><br><span class="line"><span class="comment">// defer cancel()  // releases resources if slowOperation completes before timeout elapses</span></span><br><span class="line"><span class="comment">// return slowOperation(ctx)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue"></a>WithValue</h2><p>We are coming close to doing this fully! We can read <code>WithValue</code> implementation in one go. It is a mix of <code>Context</code> and <code>key</code>-<code>value</code> pair.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WithValue returns a copy of parent in which the value associated with key is</span></span><br><span class="line"><span class="comment">// val.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Use context Values only for request-scoped data that transits processes and</span></span><br><span class="line"><span class="comment">// APIs, not for passing optional parameters to functions.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The provided key must be comparable and should not be of type</span></span><br><span class="line"><span class="comment">// string or any other built-in type to avoid collisions between</span></span><br><span class="line"><span class="comment">// packages using context. Users of WithValue should define their own</span></span><br><span class="line"><span class="comment">// types for keys. To avoid allocating when assigning to an</span></span><br><span class="line"><span class="comment">// interface&#123;&#125;, context keys often have concrete type</span></span><br><span class="line"><span class="comment">// struct&#123;&#125;. Alternatively, exported context key variables' static</span></span><br><span class="line"><span class="comment">// type should be a pointer or interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"nil key"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"key is not comparable"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A valueCtx carries a key-value pair. It implements Value for that key and</span></span><br><span class="line"><span class="comment">// delegates all other calls to the embedded Context.</span></span><br><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">Context</span><br><span class="line">key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stringify tries a bit to stringify v, without using fmt, since we don't</span></span><br><span class="line"><span class="comment">// want context depending on the unicode tables. This is only used by</span></span><br><span class="line"><span class="comment">// *valueCtx.String().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringify</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> s := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> stringer:</span><br><span class="line"><span class="keyword">return</span> s.String()</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"&lt;not Stringer&gt;"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> contextName(c.Context) + <span class="string">".WithValue(type "</span> +</span><br><span class="line">reflectlite.TypeOf(c.key).String() +</span><br><span class="line"><span class="string">", val "</span> + stringify(c.val) + <span class="string">")"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">if</span> c.key == key &#123;</span><br><span class="line"><span class="keyword">return</span> c.val</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Done-1"><a href="#Done-1" class="headerlink" title="Done"></a>Done</h2><p>uff, finally we are done with this blog post. It stretched longer than I expected. Most of the times I used to be afraid of the <code>context</code> pacakge in Go whenever I see it in some library. Now, this excercise has given me better context about the context package and probably make me less scared about using it.</p><p>I was surprised that I was naturally able to predict that there should be something like “context leak” while reading through this exercise. Hmm, so that’s for now. I would like to write about practical use case of the context API in real world codebases if I get the chance to!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This post is dedicated to you if you had used the Go programming language and ever wondered “What is a context anyway?”.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;con
      
    
    </summary>
    
    
      <category term="programming" scheme="https://vishnubharathi.codes/tags/programming/"/>
    
      <category term="go" scheme="https://vishnubharathi.codes/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>You are building it for a million people</title>
    <link href="https://vishnubharathi.codes/blog/rss-people/"/>
    <id>https://vishnubharathi.codes/blog/rss-people/</id>
    <published>2020-06-16T02:10:00.000Z</published>
    <updated>2020-07-19T14:53:35.118Z</updated>
    
    <content type="html"><![CDATA[<p>Earlier <a href="/blog/rss-features">I blogged a feature guide</a> for building a new RSS feed reader application.</p><p>You might be wondering “But, who uses RSS readers anyway?” if you are new to RSS.</p><p>I think RSS is a classic technology. It doesn’t get spoken about much. It feels like people are using it in silent or people aren’t using it at all. Because it feels relatively technical to setup RSS than setting up any other news app. For example, people may feel comfortable to install news app, rather than pick up the RSS link from the news website and load it into an RSS reader. You might disapprove, “how technical is copy pasting a link into an app?” but people might not be aware of this thing called RSS itself as news sites don’t advertise it as much as their mobile phone apps.</p><p>I tried to prototype / work on an RSS reader after my initial blogs post. After a night of hacking and learning interesting new web technologies (React + Redux), I lost some time of sleep and this question somehow started popping up to me.</p><p>Who are our audience? For whom am I building for? Will anyone ever use it? Can I get a number of RSS feed reader users somewhere? What should I be doing to gain more knowledge on this topic?</p><h2 id="Twitter-space"><a href="#Twitter-space" class="headerlink" title="Twitter space"></a>Twitter space</h2><p>I tweeted before about my RSS feature guide and got back one response!</p><p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">This is a project I&#39;ve been wanting to start for a really long time, now. Mine will probably be for Windows, though 🙂</p>&mdash; Ragesh Krishna (@rageshk) <a href="https://twitter.com/rageshk/status/1269996356694945792?ref_src=twsrc%5Etfw" target="_blank" rel="noopener">June 8, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p><p>Quite amazed to see the frequency here. So people are actually interested in building RSS readers!</p><h2 id="Email-space"><a href="#Email-space" class="headerlink" title="Email space"></a>Email space</h2><p>I emailed <a href="https://www.tbray.org/ongoing/" target="_blank" rel="noopener">Tim Bray</a> to get feedback on working on a new RSS feed reader and got back a response!</p><p>If you don’t know Tim Bray: He is one of the co-authors of the original XML specification, which is the underlying technology of RSS and also he was involved with the development of Atom web syndication. Also one of my favorite bloggers out there!</p><p>So, my guess was that he should be using an RSS reader for a really long time and went ahead in asking him feedback.</p><p>To my surprise, he replied a few minutes. It was a short and “got to learn awesome stuff” type of mail.</p><p>Most importantly He introduced me to <a href="https://inessential.com/" target="_blank" rel="noopener">Brent Simmons</a> Who had been creating this awesome RSS reader for the Apple ecosystem called the <a href="https://ranchero.com/netnewswire" target="_blank" rel="noopener">NetNewsWire</a>. I went through most of his literature on RSS readers. I would very much like to re-read them again. It really puts the vibe for the stuff I want to do.</p><h2 id="Feedly"><a href="#Feedly" class="headerlink" title="Feedly"></a>Feedly</h2><p>Feedly is probably the best RSS reader out there right now. I myself spend a lot of time with it these days. At least an hour or more than that. Both on browser and mobile clients. It feels modern!</p><p>It has some nice features. One of them is ability to see how many people are actually following an RSS feed of a particular website inside Feedly. Adding the “Follower count” game to RSS, hah! But I suppose it’s intention is to show the genuiness of a blog.</p><p>For example: A popular technology website “Engadget” has about 1.6 Million followers.</p><p><img src="https://user-images.githubusercontent.com/4211715/84727237-40864b00-afac-11ea-8fff-37e01d2441f7.png" alt="engadget"></p><p>Woah, wait. 1.6 Million? :boom:</p><p>I think, it is a great user number and it is a proof that millions of people are interested in using RSS. If you are working on an RSS feed reader app and if it takes off well, it end up a daily habit of millions of people. So while building it, build it with care and love :)</p><p>~ ~ ~ ~</p><p>Remember again and always: you are building it for a million people!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Earlier &lt;a href=&quot;/blog/rss-features&quot;&gt;I blogged a feature guide&lt;/a&gt; for building a new RSS feed reader application.&lt;/p&gt;
&lt;p&gt;You might be wo
      
    
    </summary>
    
    
      <category term="software" scheme="https://vishnubharathi.codes/tags/software/"/>
    
  </entry>
  
</feed>
